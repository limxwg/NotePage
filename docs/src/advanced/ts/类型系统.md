# 类型系统

## 类型、类型系统与类型检查

对于类型、类型系统、类型检查，你可以认为它们是不同的概念。

- 类型：限制了数据的可用操作、意义、允许的值的集合，总的来说就是**访问限制**与**赋值限制**。在 TypeScript 中即是原始类型、对象类型、函数类型、字面量类型等基础类型，以及类型别名、联合类型等经过类型编程后得到的类型。
- 类型系统：一组为变量、函数等结构分配、实施类型的规则，通过显式地指定或类型推导来分配类型。同时类型系统也定义了如何判断类型之间的兼容性：在 TypeScript 中即是结构化类型系统。
- 类型检查：确保**类型遵循类型系统下的类型兼容性**，对于静态类型语言，在**编译时**进行，而对于动态语言，则在**运行时**进行。TypeScript 就是在编译时进行类型检查的。

一个需要注意的地方是，静态类型与动态类型指的是**类型检查发生的时机**，并不等于这门语言的类型能力。比如 JavaScript 实际上是动态类型语言，它的类型检查发生在运行时。

另外一个静态类型与动态类型的重要区别体现在变量赋值时，如在 TypeScript 中无法给一个声明为 number 的变量使用字符串赋值，因为这个变量在声明时的类型就已经确定了。而在 JavaScript 中则没有这样的限制，你可以随时切换一个变量的类型。

另外，在编程语言中还有强类型、弱类型的概念，它们体现在对变量类型检查的程度，如在 JavaScript 中可以实现 `'1' - 1` 这样神奇的运算（通过隐式转换），这其实就是弱类型语言的显著特点之一。

## 结构化类型系统/标称类型系统

### 结构化系统

结构化类型系统，也称为**鸭子类型系统**，是一种类型系统，它通过检查两个类型是否具有相同的结构来决定它们是否兼容。在结构化类型系统中，一个对象是否是某个类型的实例，取决于它是否具有该类型所需的所有属性和方法，而不需要关心它的类型名称。

:::tip 鸭子类型（_Duck Typing_）
这个名字来源于**鸭子测试（_Duck Test_）**。其核心理念是，如果你看到一只鸟走起来像鸭子，游泳像鸭子，叫得也像鸭子，那么这只鸟就是鸭子。
:::

```ts
class Cat {
  eat() {}
}

class Dog {
  eat() {}
}

function feedCat(cat: Cat) {}

feedCat(new Dog());
```

正如上面的代码所示，尽管 feedCat 需要接收一个 Cat 类的实例，但是由于 Dog 类具有与 Cat 类相同的 eat 方法，因此它仍然可以被视为 Cat 类型的实例，从而可以传递给 feedCat 函数。

如果在 Cat 类中添加一个 sleep 方法呢？

```ts
class Cat {
  eat() {}
  sleep() {}
}

class Dog {
  eat() {}
}

function feedCat(cat: Cat) {}

// error
feedCat(new Dog()); // [!code error]
```

此时，由于 Dog 类没有 sleep 方法，因此它不再是 Cat 类型的实例，无法传递给 feedCat 函数。

如果不在 Cat 类中添加 sleep 方法，而是在 Dog 类中添加一个 sleep 方法呢？

```ts
class Cat {
  eat() {}
}

class Dog {
  eat() {}
  sleep() {}
}

function feedCat(cat: Cat) {}

feedCat(new Dog());
```

此时，由于 Dog 类具有与 Cat 类相同的 eat 方法，至于 sleep 方法，可以看作 Dog 类继承 Cat 类后添加的新方法，因此它仍然可以被视为 Cat 类型的实例，从而可以传递给 feedCat 函数。

结构化类型系统是 TypeScript 的核心类型系统，它允许开发者使用任何类型的对象，只要该对象具有所需的所有属性和方法，就可以被视为该类型的实例。这种灵活性使得 TypeScript 可以与许多现有的 JavaScript 库和框架无缝集成。

### 标称类型系统

标称类型系统（_Nominal Typing System_），也称为**名义类型系统**，是一种类型系统，它通过**检查两个类型的名称是否相同**来决定它们是否兼容。在标称类型系统中，一个对象是否是某个类型的实例，取决于它的类型名称，而不需要关心它是否具有该类型所需的所有属性和方法。比如以下代码：

```typescript
type USD = number;
type CNY = number;

const CNYCount: CNY = 200;
const USDCount: USD = 200;

function addCNY(source: CNY, input: CNY) {
  return source + input;
}

addCNY(CNYCount, USDCount);
```

在结构化类型系统中，USD 与 CNY （分别代表美元单位与人民币单位）被认为是两个完全一致的类型，因此在 `addCNY` 函数中可以传入 USD 类型的变量。这就很离谱了，人民币与美元这两个单位实际的意义并不一致，怎么能进行相加？

为了避免这种情况，我们可以使用标称类型系统，它通过检查两个类型的名称是否相同来决定它们是否兼容。C++、Java、Rust 等语言中都主要使用标称类型系统。

而且对于标称类型系统，父子类型关系只能通过显式的继承来实现，称为**标称子类型（Nominal Subtyping）**。

```ts
class Cat {}
// 实现一只短毛猫！
class ShorthairCat extends Cat {}
```

那么，我们是否可以在 TypeScript 中模拟出标称类型系统？

```ts
class CNY {
  private __tag!: void;
  constructor(public value: number) {}
}
class USD {
  private __tag!: void;
  constructor(public value: number) {}
}

const CNYCount = new CNY(100);
const USDCount = new USD(100);

function addCNY(source: CNY, input: CNY) {
  return source.value + input.value;
}

addCNY(CNYCount, CNYCount);

// error
addCNY(CNYCount, USDCount); // [!code error]
```

通过这种方式，我们可以在运行时添加更多的检查逻辑，同时在类型层面也得到了保障。
