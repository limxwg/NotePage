# 类型守卫

## 什么是类型守卫 🛡️

类型守卫是 TypeScript 中的一个特性，它允许你在使用特定的变量或属性之前，对变量的类型进行更精确的检查。这在处理联合类型或任何类型时特别有用，可以缩小变量的可能类型范围，从而提供更具体的类型信息给编译器。

例如 🌰：

```ts
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // 字符串处理
  } else {
    console.log(value.toFixed(2)); // 数字处理
  }
}
```

在 `if (typeof value === "string")` 分支下，TypeScript 会知道 `value` 的类型是 `string`，因此可以安全地调用 `toUpperCase` 方法。在 `else` 分支下，TypeScript 会知道 `value` 的类型是 `number`，因此可以安全地调用 `toFixed` 方法。

## 类型守卫的种类

### typeof 类型守卫

`typeof` 类型守卫用于检查变量的类型是否为特定的原始类型，如 `string`、`number`、`boolean` 等。它返回一个字符串，表示变量的类型。

```ts
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // 字符串处理
  } else {
    console.log(value.toFixed(2)); // 数字处理
  }
}
```

### instanceof 类型守卫

`instanceof` 类型守卫用于检查一个对象是否是某个构造函数的实例。它返回一个布尔值，表示对象是否是某个类的实例。

```ts
class Person {
  name: string;
  age: number;
}

class Animal {
  species: string;
}

function printValue(value: Person | Animal) {
  if (value instanceof Person) {
    console.log(value.name); // Person 属性处理
  } else {
    console.log(value.species); // Animal 属性处理
  }
}
```

### in 类型守卫

`in` 类型守卫用于检查一个对象是否具有某个属性。它返回一个布尔值，表示对象是否具有该属性。

```ts
interface Person {
  name: string;
  age: number;
}

interface Animal {
  species: string;
}

function printValue(value: Person | Animal) {
  if ("name" in value) {
    console.log(value.name); // Person 属性处理
  } else {
    console.log(value.species); // Animal 属性处理
  }
}
```

### 自定义类型守卫

在日常开发中，由于判断条件过多，我们需要将判断的条件提取出来，封装成一个函数，例如 🌰：

```ts
interface Person {
  name: string;
  age: number;
}

interface Animal {
  species: string;
}

function isPerson(value: any): boolean {
  return (
    value !== null &&
    typeof value === "object" &&
    "name" in value &&
    "age" in value
  );
}

function printValue(value: Person | Animal) {
  if (isPerson(value)) {
    // 类型“Person | Animal”上不存在属性“name”。类型“Animal”上不存在属性“name”。
    console.log(value.name); // [!code error]
  } else {
    console.log(value.species); // Animal 属性处理
  }
}
```

上面的代码看起来很简单，执行类型判断的时候如果 isPerson 返回了 true，那 value 肯定也是 isPerson 类型，但是为什么报错了呢？

因为 isPerson 这个函数在另外一个地方，内部的判断逻辑并不在函数 printValue 中。这里的类型控制流分析做不到跨函数上下文来进行类型的信息收集（但别的类型语言中可能是支持的）。

实际上，将判断逻辑封装起来提取到函数外部进行复用非常常见。为了解决这一类型控制流分析的能力不足， TypeScript 引入了 **is 关键字**来显式地提供类型信息：

```ts
function isPerson(value: any): value is Person {
  return (
    value !== null &&
    typeof value === "object" &&
    "name" in value &&
    "age" in value
  );
}

function printValue(value: Person | Animal) {
  if (isPerson(value)) {
    console.log(value.name); // Person 属性处理
  } else {
    console.log(value.species); // Animal 属性处理
  }
}
```

在这个例子中，`isPerson` 函数是一个自定义的类型守卫函数，用于检查一个对象是否是 `Person` 类型。它返回一个布尔值，表示对象是否具有 `name` 和 `age` 属性。在 `printValue` 函数中，我们使用 `isPerson` 函数来缩小变量的类型范围，从而提供更具体的类型信息给编译器。
